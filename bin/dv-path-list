#!/bin/bash
source $(dv-path lib/common.sh) # -*-mode: sh-mode -*-#!/bin/bash
# from https://claude.ai/chat/5543dc1b-4459-433d-b147-fb30d036d11a

usage() {
    echo "Usage: $0 [files/directories] [--include=pattern] [--ignore=pattern]..."
    echo
    echo "Lists files, applying gitignore-style pattern matching."
    echo
    echo "If no files/directories provided, scans current directory."
    echo "Automatically loads patterns from .gitignore and .dv/nopack.txt if they exist."
    echo
    echo "Options:"
    echo "  --include=PATTERN  Include additional files matching PATTERN"
    echo "  --ignore=PATTERN   Ignore additional files matching PATTERN"
    echo "  --help, -h        Show this help message"
    echo
    echo "Patterns follow .gitignore format:"
    echo "  *        Matches any text except /"
    echo "  **       Matches any text including /"
    echo "  /foo     Matches foo at root level"
    echo "  foo/     Matches directories"
    echo "  *.txt    Matches all .txt files"
    exit 1
}

# Convert gitignore pattern to regex
pattern_to_regex() {
    local pattern=$1
    
    # Skip empty lines and comments
    [[ -z "$pattern" || "$pattern" == \#* ]] && return
    
    # Clean pattern of carriage returns
    pattern="${pattern//[$'\r']/}"
    
    # Build the regex pattern piece by piece
    local regex=""
    
    # Handle leading pattern
    if [[ $pattern == /* ]]; then
        regex="^"
        pattern="${pattern#/}"
    else
        regex="^.*/"
    fi
    
    # Handle the main pattern, special characters first
    pattern="${pattern//./\\.}"   # Escape dots
    pattern="${pattern//\*\*/.*}" # Convert ** to .*
    pattern="${pattern//\*/[^/]*}" # Convert * to [^/]*
    
    # Add the pattern to regex
    regex="${regex}${pattern}"
    
    # Add end anchor
    regex="${regex}$"
    
    echo "$regex"
}

# Load patterns from a file
load_patterns() {
    local file=$1
    local -n patterns=$2
    
    if [[ -f "$file" ]]; then
        while IFS= read -r pattern; do
            if [[ -n "$pattern" && "$pattern" != \#* ]]; then
                local regex=$(pattern_to_regex "$pattern")
                [[ -n "$regex" ]] && patterns+=("$regex")
            fi
        done < "$file"
    fi
}

# Initialize arrays
declare -a include_patterns=()
declare -a ignore_patterns=()
declare -a base_paths=()

# Load ignore patterns from .gitignore and .dv/nopack.txt
load_patterns ".gitignore" ignore_patterns
load_patterns ".dv/nopack.txt" ignore_patterns

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --include=*)
            pattern="${1#*=}"
            regex=$(pattern_to_regex "$pattern")
            [[ -n "$regex" ]] && include_patterns+=("$regex")
            shift
            ;;
        --ignore=*)
            pattern="${1#*=}"
            regex=$(pattern_to_regex "$pattern")
            [[ -n "$regex" ]] && ignore_patterns+=("$regex")
            shift
            ;;
        --help|-h)
            usage
            ;;
        --*)
            echo "Unknown option: $1" >&2
            usage
            ;;
        *)
            base_paths+=("$1")
            shift
            ;;
    esac
done

# Function to check if a file should be ignored
should_ignore() {
    local file=$1
    for pattern in "${ignore_patterns[@]}"; do
        if [[ "$file" =~ $pattern ]]; then
            return 0
        fi
    done
    return 1
}

# Process files
if [ "${#base_paths[@]}" -gt 0 ]; then
    for path in "${base_paths[@]}"; do
        if [ -f "$path" ]; then
            if ! should_ignore "$path"; then
                echo "$path"
            fi
        elif [ -d "$path" ]; then
            while IFS= read -r -d '' file; do
                # Remove leading ./
                file="${file#./}"
                if ! should_ignore "$file"; then
                    echo "$file"
                fi
            done < <(find "$path" -type f -print0)
        else
            echo "Warning: '$path' not found" >&2
        fi
    done
else
    while IFS= read -r -d '' file; do
        file="${file#./}"
        if ! should_ignore "$file"; then
            echo "$file"
        fi
    done < <(find . -type f -print0)
fi | if [ "${#include_patterns[@]}" -gt 0 ]; then
    while IFS= read -r file; do
        for pattern in "${include_patterns[@]}"; do
            if [[ "$file" =~ $pattern ]]; then
                echo "$file"
                break
            fi
        done
    done
else
    cat
fi | sort
