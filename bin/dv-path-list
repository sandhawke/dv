#!/bin/bash
source $(dv-path lib/common.sh) # -*-mode: sh-mode -*-#!/bin/bash
# from https://claude.ai/chat/5543dc1b-4459-433d-b147-fb30d036d11a
#!/bin/bash

DEBUG=${DEBUG:-}

debug() {
    [[ -n "$DEBUG" ]] && echo "DEBUG: $*" >&2
}

usage() {
    echo "Usage: $0 [files/directories] [--include=pattern] [--ignore=pattern]..."
    echo
    echo "Lists files, applying gitignore-style pattern matching."
    echo
    echo "If no files/directories provided, scans current directory."
    echo "Automatically loads patterns from .gitignore and .dv/nopack.txt if they exist."
    echo
    echo "Options:"
    echo "  --include=PATTERN  Include additional files matching PATTERN"
    echo "  --ignore=PATTERN   Ignore additional files matching PATTERN"
    echo "  --help, -h        Show this help message"
    echo
    echo "Patterns follow .gitignore format:"
    echo "  *        Matches any text except /"
    echo "  **       Matches any text including /"
    echo "  /foo     Matches foo at root level"
    echo "  foo/     Matches directories"
    echo "  *.txt    Matches all .txt files"
    exit 1
}

# Check if a path matches a pattern
matches_pattern() {
    local path=$1
    local pattern=$2
    
    # Remove leading ./ and trailing /
    path="${path#./}"
    path="${path%/}"
    pattern="${pattern#./}"
    pattern="${pattern%/}"
    
    debug "Checking if '$path' matches pattern '$pattern'"
    
    # If pattern ends in /, it matches directories and everything under them
    if [[ $pattern == */ ]]; then
        pattern="${pattern%/}"
        [[ $path == $pattern/* ]] && return 0
        [[ $path == $pattern ]] && return 0
        return 1
    fi
    
    # If pattern starts with /, anchor to root
    if [[ $pattern == /* ]]; then
        pattern="${pattern#/}"
        [[ $path == $pattern ]] && return 0
        return 1
    fi
    
    # If pattern contains /, match whole path component
    if [[ $pattern == */* ]]; then
        [[ $path == *$pattern* ]] && return 0
        return 1
    fi
    
    # Otherwise match any path component
    local comp
    while [[ $path == */* ]]; do
        comp="${path##*/}"
        [[ $comp == $pattern ]] && return 0
        path="${path%/*}"
    done
    [[ $path == $pattern ]] && return 0
    return 1
}

# Load patterns from a file
load_patterns() {
    local file=$1
    local -n patterns=$2
    
    if [[ -f "$file" ]]; then
        debug "Loading patterns from $file"
        while IFS= read -r pattern; do
            if [[ -n "$pattern" && "$pattern" != \#* ]]; then
                patterns+=("$pattern")
                debug "Added pattern: $pattern"
            fi
        done < "$file"
    fi
}

# Initialize arrays
declare -a include_patterns=()
declare -a ignore_patterns=()
declare -a base_paths=()

# Load ignore patterns from .gitignore and .dv/nopack.txt
load_patterns ".gitignore" ignore_patterns
load_patterns ".dv/nopack.txt" ignore_patterns

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --include=*)
            pattern="${1#*=}"
            include_patterns+=("$pattern")
            shift
            ;;
        --ignore=*)
            pattern="${1#*=}"
            ignore_patterns+=("$pattern")
            shift
            ;;
        --help|-h)
            usage
            ;;
        --*)
            echo "Unknown option: $1" >&2
            usage
            ;;
        *)
            # Add trailing slash to directories for consistent handling
            if [ -d "$1" ]; then
                base_paths+=("${1%/}/")
            else
                base_paths+=("$1")
            fi
            shift
            ;;
    esac
done

# Process files
process_files() {
    local files=""
    
    # Get initial file list
    if [ "${#base_paths[@]}" -gt 0 ]; then
        for path in "${base_paths[@]}"; do
            if [ -f "$path" ]; then
                echo "$path"
            elif [ -d "$path" ]; then
                find "$path" -type f | sed 's#^\./##'
            else
                echo "Warning: '$path' not found" >&2
            fi
        done
    else
        find . -type f | sed 's#^\./##'
    fi | while IFS= read -r file; do
        # Skip if file matches any ignore pattern
        local ignore=false
        for pattern in "${ignore_patterns[@]}"; do
            if matches_pattern "$file" "$pattern"; then
                debug "File '$file' matches ignore pattern '$pattern'"
                ignore=true
                break
            fi
        done
        
        if $ignore; then
            debug "Ignoring file: $file"
            continue
        fi
        
        # Include file if no include patterns or if it matches any include pattern
        if [ "${#include_patterns[@]}" -eq 0 ]; then
            debug "Including file (no include patterns): $file"
            echo "$file"
        else
            for pattern in "${include_patterns[@]}"; do
                if matches_pattern "$file" "$pattern"; then
                    debug "Including file (matches $pattern): $file"
                    echo "$file"
                    break
                fi
            done
        fi
    done | sort
}

# Enable extended globbing
shopt -s extglob nullglob

process_files
