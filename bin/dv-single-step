#!/bin/bash
source $(dv-path lib/common.sh) # -*-mode: sh-mode -*-

# Beautiful session: https://claude.ai/chat/55db8e25-3ce3-42c2-b370-b5ec136e0943

STATE_DIR="${HOME}/.step"
LOCK_TIMEOUT=10

log_debug "Starting dv-single-step"
log_debug "State directory: $STATE_DIR"

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] CMDFILE
Execute commands from CMDFILE one at a time, with failure tracking and stats.

Options:
  --state=NAME    Use state file NAME (default: default)
  --reset=N       Reset to make step N the next to execute
  --list          Show all steps with status and stats
  --dryrun        Show what would be executed next
  --help          Show this help message

State and logs are kept in ${STATE_DIR}/
EOF
    exit 1
}

# Create state directory if it doesn't exist
log_debug "Creating state directory if needed"
mkdir -p "${STATE_DIR}"

# Parse arguments
CMDFILE=""
STATE_NAME="default"
RESET_TO=""
LIST_MODE=0
DRYRUN=0

log_debug "Parsing command line arguments"
while [[ $# -gt 0 ]]; do
    log_debug "Processing argument: $1"
    case $1 in
        --state=*)
            STATE_NAME="${1#*=}"
            log_debug "Setting state name to: $STATE_NAME"
            shift
            ;;
        --reset=*)
            RESET_TO="${1#*=}"
            log_debug "Setting reset point to: $RESET_TO"
            shift
            ;;
        --list)
            LIST_MODE=1
            log_debug "List mode enabled"
            shift
            ;;
        --dryrun)
            DRYRUN=1
            log_debug "Dry run mode enabled"
            shift
            ;;
        --help)
            usage
            ;;
        *)
            if [[ -z "$CMDFILE" ]]; then
                CMDFILE="$1"
                log_debug "Setting command file to: $CMDFILE"
            else
                echo "Error: Unexpected argument: $1" >&2
                usage
            fi
            shift
            ;;
    esac
done

if [[ -z "$CMDFILE" ]]; then
    echo "Error: No command file specified" >&2
    usage
fi

if [[ ! -f "$CMDFILE" ]]; then
    echo "Error: Command file not found: $CMDFILE" >&2
    exit 1
fi

log_debug "Validating command file syntax"
if ! grep -qv '^\s*\(#.*\)\?$' "$CMDFILE"; then
    echo "Error: Command file is empty or contains only comments" >&2
    exit 1
fi

STATE_FILE="${STATE_DIR}/${STATE_NAME}"
LOCK_FILE="${STATE_FILE}.lock"
BACKUP_FILE="${STATE_FILE}.bak"

log_debug "Using state file: $STATE_FILE"
log_debug "Using lock file: $LOCK_FILE"

# Initialize state file if it doesn't exist
init_state() {
    log_debug "Initializing state file"
    if [[ ! -f "$STATE_FILE" ]]; then
        log_debug "Creating new state file"
        echo '{
            "current_step": 0,
            "steps": {},
            "cmdfile": "",
            "last_modified": ""
        }' > "$STATE_FILE"
    fi

    # Validate state file
    log_debug "Validating state file"
    if ! jq empty "$STATE_FILE" 2>/dev/null; then
        echo "Error: State file is corrupted" >&2
        exit 1
    fi
}

# Get/set JSON values using jq
get_json_value() {
    local key="$1"
    log_debug "Getting JSON value for key: $key"
    jq -r ".$key" "$STATE_FILE"
}

set_json_value() {
    local key="$1"
    local value="$2"
    log_debug "Setting JSON value for key: $key to: $value"
    local tmp_file="${STATE_FILE}.tmp"
    jq ".$key = $value" "$STATE_FILE" > "$tmp_file"
    mv "$tmp_file" "$STATE_FILE"
}

# Update step statistics
update_step_stats() {
    local step_num="$1"
    local exit_code="$2"
    local duration="$3"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    log_debug "Updating stats for step $step_num (exit_code=$exit_code, duration=$duration)"

    if [[ $exit_code -eq 0 ]]; then
        log_debug "Recording successful execution"
        jq --arg sn "$step_num" \
           --arg ts "$timestamp" \
           --arg dur "$duration" \
           '.steps[$sn].last_success = $ts |
            .steps[$sn].success_duration = $dur |
            .steps[$sn].last_exit_code = 0' "$STATE_FILE" > "${STATE_FILE}.tmp"
    else
        log_debug "Recording failed execution"
        jq --arg sn "$step_num" \
           --arg ts "$timestamp" \
           --arg dur "$duration" \
           --arg ec "$exit_code" \
           '.steps[$sn].last_failure = $ts |
            .steps[$sn].failure_count = (.steps[$sn].failure_count // 0) + 1 |
            .steps[$sn].total_failure_duration = (.steps[$sn].total_failure_duration // 0) + ($dur | tonumber) |
            .steps[$sn].last_exit_code = ($ec | tonumber)' "$STATE_FILE" > "${STATE_FILE}.tmp"
    fi
    mv "${STATE_FILE}.tmp" "$STATE_FILE"
}

# Get formatted command with step number
get_command() {
    local step_num="$1"
    log_debug "Getting command for step $step_num"
    local cmd
    cmd=$(sed -n "$((step_num + 1))p" "$CMDFILE" | grep -v '^\s*#' | grep -v '^\s*$' || true)
    log_debug "Retrieved command: $cmd"
    echo "$cmd"
}

# Display step status with stats
show_step_status() {
    local step_num="$1"
    local cmd
    cmd=$(get_command "$step_num")
    if [[ -z "$cmd" ]]; then
        return
    fi

    log_debug "Showing status for step $step_num"
    local stats
    stats=$(jq -r --arg sn "$step_num" '.steps[$sn] // empty' "$STATE_FILE")

    printf "Step %d: %s\n" "$step_num" "$cmd"
    if [[ -n "$stats" ]]; then
        echo "$stats" | jq -r '
            if .last_success then "  ✓ Last success: \(.last_success)\n    Duration: \(.success_duration)s" else "" end +
            if .failure_count then "\n  ✗ Failed \(.failure_count) times\n    Total failure time: \(.total_failure_duration)s\n    Last failure: \(.last_failure)" else "" end
        '
    fi
    echo
}

# Main execution
log_debug "Starting main execution block"
(
    # Acquire lock
    log_debug "Attempting to acquire lock"
    if ! flock -w $LOCK_TIMEOUT 200; then
        echo "Error: Could not acquire lock within $LOCK_TIMEOUT seconds" >&2
        exit 1
    fi
    log_debug "Lock acquired successfully"

    init_state

    # Check if command file has changed
    cmdfile_mtime=$(stat -c %Y "$CMDFILE")
    last_mtime=$(get_json_value "last_modified")

    log_debug "Command file mtime: $cmdfile_mtime, Last recorded mtime: $last_mtime"
    if [[ "$cmdfile_mtime" != "$last_mtime" ]]; then
        log_debug "Command file has changed, updating state"
        cp "$STATE_FILE" "$BACKUP_FILE"
        set_json_value "cmdfile" "\"$CMDFILE\""
        set_json_value "last_modified" "$cmdfile_mtime"
    fi

    # Handle --reset
    if [[ -n "$RESET_TO" ]]; then
        log_debug "Processing reset request to step $RESET_TO"
        cp "$STATE_FILE" "$BACKUP_FILE"
        set_json_value "current_step" "$RESET_TO"
        echo "Reset to step $RESET_TO"
        exit 0
    fi

    # Handle --list
    if [[ $LIST_MODE -eq 1 ]]; then
        log_debug "Processing list mode request"
        current_step=$(get_json_value "current_step")
        step_num=0
        while true; do
            cmd=$(get_command "$step_num")
            [[ -z "$cmd" ]] && break

            if [[ $step_num -eq $current_step ]]; then
                echo "→ [Current]"
            fi
            show_step_status "$step_num"
            ((step_num++))
        done
        exit 0
    fi

    # Get current step
    current_step=$(get_json_value "current_step")
    cmd=$(get_command "$current_step")

    log_debug "Current step: $current_step"
    log_debug "Current command: $cmd"

    if [[ -z "$cmd" ]]; then
        echo "No more commands to execute. Use --reset=0 to start over."
        exit 0
    fi

    # Handle --dryrun
    if [[ $DRYRUN -eq 1 ]]; then
        log_debug "Processing dry run request"
        echo "Next command to execute:"
        show_step_status "$current_step"
        exit 0
    fi

    # Execute command
    echo "Executing step $current_step: $cmd"
    start_time=$(date +%s.%N)

    log_debug "Starting command execution"
    set +e
    output=$(eval "$cmd" 2>&1)
    exit_code=$?
    set -e
    log_debug "Command completed with exit code $exit_code"

    end_time=$(date +%s.%N)
    duration=$(echo "$end_time - $start_time" | bc)

    # Update stats and show output
    log_debug "Backing up state file before updates"
    cp "$STATE_FILE" "$BACKUP_FILE"
    update_step_stats "$current_step" "$exit_code" "$duration"

    echo "$output"

    if [[ $exit_code -eq 0 ]]; then
        echo "Step $current_step completed successfully in ${duration}s"
        log_debug "Advancing to next step"
        cp "$STATE_FILE" "$BACKUP_FILE"
        set_json_value "current_step" "$((current_step + 1))"

        # Check if we're done
        next_cmd=$(get_command "$((current_step + 1))")
        if [[ -z "$next_cmd" ]]; then
            echo "All steps completed! Use --reset=0 to start over."
        fi
    else
        echo "Step $current_step failed with exit code $exit_code (${duration}s)"
        echo "Run step again to retry"
    fi

) 200>"$LOCK_FILE"

log_debug "Script completed"
