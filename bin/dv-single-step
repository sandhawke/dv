#!/bin/bash
source $(dv-path lib/common.sh) # -*-mode: sh-mode -*-

# Beautiful session: https://claude.ai/chat/55db8e25-3ce3-42c2-b370-b5ec136e0943


STATE_DIR="${HOME}/.step"
LOCK_TIMEOUT=10

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] CMDFILE
Execute commands from CMDFILE one at a time, with failure tracking and stats.

Options:
  --state=NAME    Use state file NAME (default: default)
  --reset=N       Reset to make step N the next to execute
  --list          Show all steps with status and stats
  --dryrun        Show what would be executed next
  --help          Show this help message

State and logs are kept in ${STATE_DIR}/
EOF
    exit 1
}

# Create state directory if it doesn't exist
mkdir -p "${STATE_DIR}"

# Parse arguments
CMDFILE=""
STATE_NAME="default"
RESET_TO=""
LIST_MODE=0
DRYRUN=0

while [[ $# -gt 0 ]]; do
    case $1 in
        --state=*)
            STATE_NAME="${1#*=}"
            shift
            ;;
        --reset=*)
            RESET_TO="${1#*=}"
            shift
            ;;
        --list)
            LIST_MODE=1
            shift
            ;;
        --dryrun)
            DRYRUN=1
            shift
            ;;
        --help)
            usage
            ;;
        *)
            if [[ -z "$CMDFILE" ]]; then
                CMDFILE="$1"
            else
                echo "Error: Unexpected argument: $1" >&2
                usage
            fi
            shift
            ;;
    esac
done

if [[ -z "$CMDFILE" ]]; then
    echo "Error: No command file specified" >&2
    usage
fi

if [[ ! -f "$CMDFILE" ]]; then
    echo "Error: Command file not found: $CMDFILE" >&2
    exit 1
fi

STATE_FILE="${STATE_DIR}/${STATE_NAME}"
LOCK_FILE="${STATE_FILE}.lock"
BACKUP_FILE="${STATE_FILE}.bak"

# Initialize state file if it doesn't exist
init_state() {
    if [[ ! -f "$STATE_FILE" ]]; then
        echo '{
            "current_step": 0,
            "steps": {},
            "cmdfile": "",
            "last_modified": ""
        }' > "$STATE_FILE"
    fi
}

# Get/set JSON values using jq
get_json_value() {
    local key="$1"
    jq -r ".$key" "$STATE_FILE"
}

set_json_value() {
    local key="$1"
    local value="$2"
    local tmp_file="${STATE_FILE}.tmp"
    jq ".$key = $value" "$STATE_FILE" > "$tmp_file"
    mv "$tmp_file" "$STATE_FILE"
}

# Update step statistics
update_step_stats() {
    local step_num="$1"
    local exit_code="$2"
    local duration="$3"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    if [[ $exit_code -eq 0 ]]; then
        # Success
        jq --arg sn "$step_num" \
           --arg ts "$timestamp" \
           --arg dur "$duration" \
           '.steps[$sn].last_success = $ts |
            .steps[$sn].success_duration = $dur |
            .steps[$sn].last_exit_code = 0' "$STATE_FILE" > "${STATE_FILE}.tmp"
    else
        # Failure
        jq --arg sn "$step_num" \
           --arg ts "$timestamp" \
           --arg dur "$duration" \
           --arg ec "$exit_code" \
           '.steps[$sn].last_failure = $ts |
            .steps[$sn].failure_count = (.steps[$sn].failure_count // 0) + 1 |
            .steps[$sn].total_failure_duration = (.steps[$sn].total_failure_duration // 0) + ($dur | tonumber) |
            .steps[$sn].last_exit_code = ($ec | tonumber)' "$STATE_FILE" > "${STATE_FILE}.tmp"
    fi
    mv "${STATE_FILE}.tmp" "$STATE_FILE"
}

# Get formatted command with step number
get_command() {
    local step_num="$1"
    sed -n "$((step_num + 1))p" "$CMDFILE" | grep -v '^\s*#' | grep -v '^\s*$' || true
}

# Display step status with stats
show_step_status() {
    local step_num="$1"
    local cmd
    cmd=$(get_command "$step_num")
    if [[ -z "$cmd" ]]; then
        return
    fi
    
    local stats
    stats=$(jq -r --arg sn "$step_num" '.steps[$sn] // empty' "$STATE_FILE")
    
    printf "Step %d: %s\n" "$step_num" "$cmd"
    if [[ -n "$stats" ]]; then
        echo "$stats" | jq -r '
            if .last_success then "  ✓ Last success: \(.last_success)\n    Duration: \(.success_duration)s" else "" end +
            if .failure_count then "\n  ✗ Failed \(.failure_count) times\n    Total failure time: \(.total_failure_duration)s\n    Last failure: \(.last_failure)" else "" end
        '
    fi
    echo
}

# Main execution
(
    # Acquire lock
    if ! flock -w $LOCK_TIMEOUT 200; then
        echo "Error: Could not acquire lock within $LOCK_TIMEOUT seconds" >&2
        exit 1
    fi
    
    init_state
    
    # Check if command file has changed
    cmdfile_mtime=$(stat -c %Y "$CMDFILE")
    last_mtime=$(get_json_value "last_modified")
    
    if [[ "$cmdfile_mtime" != "$last_mtime" ]]; then
        cp "$STATE_FILE" "$BACKUP_FILE"
        set_json_value "cmdfile" "\"$CMDFILE\""
        set_json_value "last_modified" "$cmdfile_mtime"
    fi
    
    # Handle --reset
    if [[ -n "$RESET_TO" ]]; then
        cp "$STATE_FILE" "$BACKUP_FILE"
        set_json_value "current_step" "$RESET_TO"
        echo "Reset to step $RESET_TO"
        exit 0
    fi
    
    # Handle --list
    if [[ $LIST_MODE -eq 1 ]]; then
        current_step=$(get_json_value "current_step")
        step_num=0
        while true; do
            cmd=$(get_command "$step_num")
            [[ -z "$cmd" ]] && break
            
            if [[ $step_num -eq $current_step ]]; then
                echo "→ [Current]"
            fi
            show_step_status "$step_num"
            ((step_num++))
        done
        exit 0
    fi
    
    # Get current step
    current_step=$(get_json_value "current_step")
    cmd=$(get_command "$current_step")
    
    if [[ -z "$cmd" ]]; then
        echo "No more commands to execute. Use --reset=0 to start over."
        exit 0
    fi
    
    # Handle --dryrun
    if [[ $DRYRUN -eq 1 ]]; then
        echo "Next command to execute:"
        show_step_status "$current_step"
        exit 0
    fi
    
    # Execute command
    echo "Executing step $current_step: $cmd"
    start_time=$(date +%s.%N)
    
    set +e
    output=$(eval "$cmd" 2>&1)
    exit_code=$?
    set -e
    
    end_time=$(date +%s.%N)
    duration=$(echo "$end_time - $start_time" | bc)
    
    # Update stats and show output
    cp "$STATE_FILE" "$BACKUP_FILE"
    update_step_stats "$current_step" "$exit_code" "$duration"
    
    echo "$output"
    
    if [[ $exit_code -eq 0 ]]; then
        echo "Step $current_step completed successfully in ${duration}s"
        cp "$STATE_FILE" "$BACKUP_FILE"
        set_json_value "current_step" "$((current_step + 1))"
        
        # Check if we're done
        next_cmd=$(get_command "$((current_step + 1))")
        if [[ -z "$next_cmd" ]]; then
            echo "All steps completed! Use --reset=0 to start over."
        fi
    else
        echo "Step $current_step failed with exit code $exit_code (${duration}s)"
        echo "Run step again to retry"
    fi
    
) 200>"$LOCK_FILE" # the 200 is the fd we us in flock (arbitrary 3-255)
