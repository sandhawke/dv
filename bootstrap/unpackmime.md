The code generated by the below prompt had some errors in the parser. I then asked for a test suite and let it iterate on the code until it passed the test suite. I think it took seven rounds.

This was the initial prompt:


Here is the specification for a simple unix command I want you to implement in nodeJS (v21+, type: module). Please just respond with the javascript text of the file, starting `#!/usr/bin/env node`. The package.json is already set up, and I can import any necessary modules. If you have any concerns, issues, or questions, put them in comments inside the program.

The command is "unpackmime" and it takes a filename parameter (or "-" for stdin) and reads it as mime-multipart-encoded archive entity. In normal operation, each attachment part is turned into a file. Without any parameters, it prints a usage statement.

If any file would overwrite an existing file, operation stops with an error before any files are modified. This behavior can be changed with the --force option which makes overwrites proceed.

If any file would be written outside the file tree rooted at the current directory, or which matched an excluded pattern, operation stops with an error before any files are modified.

Excluded patterns are specified using .gitignore, or a file specified with --exclude-from=. The ".git" pattern is implicitly added.

If --preserve is given, attachments with a last-modified time given have their last-modified time in the filesystem set to match what's in the multipart archive.

If the "X-Unix-Mode" header is present on a part, use it to set the executable bits on the file. If --preserve is given, also use X-Unix-Mode to set read and write and setuid bits.

If attachements are base64 encoded in the archive per the mime standard, the program restores the bytes before writing the output file, as normal.

If any form parts are present, they are treated as files, with a name transformation. A form field named "x" is treated as an attached file named "form-fields/x".

If the archive does not end properly, perhaps by being truncated, operation proceeds on all the parts which are properly terminated, and the unterminated content is ignored, with a red warning printed to stderr.

Do not use an existing mime multipart parsing library. We need to be more lenient than they are. We need to succesfully parse archives with the wrong line terminators (LF instead of CR LF). The only mime header we should require is content-disposition. We should allow either "name" or "filename" to be used to specify the filename. We don't need the header "Content-Type: multipart/mixed; boundary=" since we can just use a line starting with "--" to tell us the boundary. Do not corrupt any of the text of the parts themselves, though.

As a variation on --force, the --patch flag says we can safely overwrite any file that is tracked in git and has all changes committed.

Offer a --dryrun option which just says what would happen.

On completion, send to stderr a summary of what happened, including all the files that were created and how many bytes were written to each.

Actually, make the lenient mime multipart parser an exported function in a separate file, for better unit testing.

